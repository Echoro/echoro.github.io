---
title: 补档：大二下微电子课程计算机软件基础期末总结

date: 2024/12/1 12:29:00 +0800

categories: [微电子,大二下]

tags: [计算机软件基础]
comments: true

# 其他还有：
description: 这是复旦大学微电子专业大二下计算机软件基础课程总结。主要是copy了讲义，变成了md形式，索引更方便，适合期末食用
author: echoro
link: https://github.com/Echoro/FDU_weidianzi_jiruan.git 
toc: true # 关闭目录
math: true # 加载数学功能
mermaid: true # 启用Mermaid
pin: false # 置顶帖子
# img_path: echoro/

---
😚
c复习：

1. C语言中n++和++n的区别

n++是先使用n的数值再自加一； ++n是先自加一再使用n累加后的数值。++ 前置时，自增表达式（如 ++n）的值等于其操作数自增后的值；++ 后置时，自增表达式（如 n++）的值等于其操作数自增前的值。

2. `int isalnum(int c)`检查给定的字符是否是字母或数字。如果字符是字母或数字，`isalnum` 函数返回非零值（通常是1），否则返回0。

3. `scanf与fscanf`的返回值是成功匹配并读取的输入项的数量

4. ABS（）返回数据绝对值

5. ```
   int strcmp(const char *str1, const char *str2)
   ```

   如果返回值小于 0，则表示 str1 小于 str2。

   如果返回值大于 0，则表示 str1 大于 str2。

   如果返回值等于 0，则表示 str1 等于 str2

   

# 第四章：数据结构

## 基本概念：

**什么是软件**

软件Software = 程序Program + 文档Documentation  

 程序  为实现某种任务编写的计算机指令集，以控制计算机的工作流程，完成一定的逻辑功能。  

 文档  描述软件的定义、开发和运行各阶段活动的图文信息资料。

**什么是程序**

程序Program = 数据结构Data Structure + 算法Algorithm  

 数据结构─ ─两个涵义  

逻辑结构：客观事物自身所具有的结构特点，例如家族谱系是一个天然的树型结构；  

物理结构：逻辑结构在计算机中的具体实现，例如树型结构用指针还是数组实现。  

 算法：程序的逻辑抽象，是解决某类客观问题的数学过程。

**什么是数据结构**

 数据性质： 数据类型和相互关系  

 数据表示： 如何在计算机中存储  

 数据处理： 如何对数据进行操作

### 数据结构的定义

#### 数据结构的定义

定义B是一个二元组B=(K,R)。K是数据(或结点)的集合，

记为K={k1, k2,  …, kn }。

R是K中各数据之间的一种关系，记为R={(ks, kt), ks,kt∈K}。  

例如，数字0到9及其之间的大于关系是一种数据结构。  

K={0, 1, …, 9}，R={(1, 0), (2, 0), (2, 1), …}。

#### 前件和后件

如果(k, k’∈K)，(k, k’)∈R, 则称 k 是 k’的前驱结点，简称前件，k’是k的后续结点，简 称后件。在图中用箭头从k指向k’。

![image-20240621100523230](/img/wdz_jr_final/image-20240621100523230.png)

#### 结点性质

 始结点  若在K中不存在任何k’，使得成立(k’,k)∈R, 则称k为始结点。  

 终结点  若在K中不存在任何k’，使得成立(k,k’)∈R, 则称k为终结点。

 内结点  既非始结点又非终结点的称为内结点。

 孤立结点  既无前件又无后件的称为孤立结点，不予讨论。

![image-20240621100630939](/img/wdz_jr_final/image-20240621100630939.png)

### 数据结构的存储方式

将结点k的地址记为$\alpha$ k，结点指针值记为pk。 

####  顺序存储

若对于任何一对结点(k, k’)都成立$\alpha$k’ = $\alpha$k + S(S为存储单元的大小)，则称r是**顺序方式** 存储的。通常可用**数组**实现数据结构的顺序存储，**数组元素的下标就是结点地址**。

#### 链接存储

若对于任何一对结点(k, k’)都成立$\alpha$k’∈pk，则称r是**链接存储**的。通常用**链表**实现的数据 结构是一种**基本的链接存储。** 

![image-20240621101053913](/img/wdz_jr_final/image-20240621101053913.png)

### 数据结构的分类

根据结点的相互关系分类 

(1) 线性结构：只有一个始结点和一个终结点，各结点的前件和后件数至多一个。  

(2) 树状结构：只有一个始结点，各结点的前件数至多一个。  

(3) 网状结构：始结点和终结点的数目任意，各结点的前件和后件数任意。 

![image-20240621103847851](/img/wdz_jr_final/image-20240621103847851.png)

### 数据结构的基本操作

数据结构的基本操作包括**查找，增添，删除和排序**。 

####  查找

根据序号或数值、结点的前件或后件等属性查找结点。  

例如，查找结点值为key=6的结点，即查找k i ==6，得i=5。

####  遍历

按照某种规律列出数据结构的部分结点或者所有结点。  

例如，图示数据结构的顺序遍历结果为{7,5,2,1,3,6 }，逆序遍历结果为{6,3,1,2,5,7}。 

![image-20240621103952113](/img/wdz_jr_final/image-20240621103952113.png)

#### 增添

在保持数据结构的特点不变情况下，增加若干个结点。  

例如，在已有的数据结构中增添两个结点：

![image-20240621130813185](/img/wdz_jr_final/image-20240621130813185.png)

####  删除

在保持数据结构的特点不变情况下，删去某些结点。  

例如，在已有的数据结构中删除两个结点： 

![image-20240621130846249](/img/wdz_jr_final/image-20240621130846249.png)

#### 排序

按某种方式使各结点有序排列。  

例如，使图示数据结构中的结点按照从小到大排序：

![image-20240621130909428](/img/wdz_jr_final/image-20240621130909428.png)

### 算法复杂度

#### 什么是算法复杂度

同一问题可用不同算法解决，而一个算法的质量优劣将影响到程序的效率，算法的评价 主要从时间复杂度和空间复杂度来考虑。  

 时间复杂度  

运行时间：程序所用算法运行时所要花费的**时间代价**  

 空间复杂度  

占用空间：程序中使用的数据结构占有的**空间代价**  

由于硬件技术的发展大大提高了计算机的存储容量，使得存储容量的局限性对于算法的 影响大大降低。但是**时间效率并没有得到相应程度的提高**。  因此，本课程讨论的算法复杂度**主要指算法的时间复杂度**。 

#### 算法复杂度的衡度

**算法的复杂度主要取决于输入数据的规模和算法执行的方法**。  

假定输入数据的规模为n，当n值比较小的时候，例如n≤10时，  n = 10，2*n = 20，n2 = 100，n3 = 1000  

在计算机中运行的时间都差不多，运行10000次也是瞬间就可完成的。

但是如果 n>10000 甚至更大，运行时间就很可观了。而对于例如2n这种指数级或者更复杂的算法， 当n足够大时，现代计算机都无法承受。  

通常，用**大O形式(Omicron)表示算法复杂度**，其**表示方法为O(f(n))，其中f(n)是n 的函数**。  

例如，如果运算时间f(n)~n2，时间复杂度计为O(n2)。  如果运算时间与n无关，时间复杂度计为O(C)，C是常数

####  算法复杂度曲线

随着n的增大，算法复杂度曲线可反映一个算法的优劣。

![image-20240621131243356](/img/wdz_jr_final/image-20240621131243356.png)

####  算法复杂度的运算规则

##### **简单运算法则  **

**用N表示常量，n表示数据规模**，且n>>N，则有：   

O(N+n) = O(n)，O(N•n) = O(n)   

O(N•n2) = O(n2)，O(N•n3) = O(n3)   

O(N2•n2) = O(n2)，O(n2/2) = O(n2)，…

##### 加法规则

f1(n) + f2(n) = O(max(f1(n), f2(n)))  

对应于程序中的**顺序结构和if等条件结构**。  

例如：   O(N•n2) + O(M•n2) = O(max(N•n2), (M•n2)))   O(n2) + O(n3) = O(n3)  

如果N<<n，M<<n，

O(N•n2) + O(M•n2) = O(n2)  否则，   

O(N•n2) + O(M•n2) = O(max(N•n2), (M•n2))) 

##### 乘法规则

f1(n) • f2(n) = O(f1(n) • f2(n))  对应于程序中的**for和while等循环结构**。  

例如：   O(N•n2) • O(M•n2) = O(N•M•n4)   O(n2) • O(n3) = O(n5)…  

如果N<<n，M<<n，

O(N•n2) • O(M•n2) = O(n4)  

否则，   O(N•n2) • O(M•n2) = O(N•M•n4)

 算法复杂度计算示例2   

```c
define N 10000   
void func(int A[], int B[], int n)  
    /* n < N  */   
{    
    int i, j;    
	for(i=0; i<n; i++) 
   { 
    A[i] = 0; 
    for(j=0; j<=i; j++) 
      A[i] = A[i] * B[j]; 
   } 
} 
```

外层for循环的运行次数为n，内层for循环运行次数依次为：  

 1, 2, …, n-2, n-1  

则以上二重循环的运行次数为：   

1 + 2 + … + (n-2) + (n-1) = (n-1) * n / 2 ≈ n2 / 2  

所以，算法复杂度为O(n2/2) = O(n2)。



*注：for循环嵌套是算法复杂度相乘，也可以像这样列出并求和*



##### 算法复杂度的最坏情况

 输入数据规模为n，算法运行的时间可有三种情况：  

 最坏情况(Worst Case)：任意输入规模的最大运行时间。  

 平均情况(Average Case)：任意输入规模的期待运行时间。  

 最佳情况(Best Case)：通常最佳情况不会出现。  

例如，在n个数据中顺序搜索某个指定的值，对应的三种情况为：  

 最坏情况：n次比较  

 平均情况：n/2次比较  

 最佳情况：1次比较  实际上，用最佳情况考量算法毫无意义。大体上看，平均情况通常与最坏情况一样差， 这是运行时间的一个上界。因此**总是用最坏情况来考量一个算法的优劣**。 

##### NP复杂度

非确定性多项式时间复杂度(non-deterministic polynomial)，简称NP复杂度。  

简单地说，就是在多项式时间内对一个判定性算法问题能否给出一个正确的解。  

具有NP复杂度的算法问题称为NP问题。  

典型的例子，就是不能在多项式时间内给出n个元素的全排列。  特别要指出的是在集成电路设计的算法中，有许多问题都是属于NP问题，这对微电子 专业的科研工作者是一项不可忽视的挑战。



### 数据结构的学习内容

 数据类型： 线性，树状，网状。  

 存储方式： 顺序存储，链接存储。

 基本操作： 查找，增添，删除和排序。  

 算法实现： 本课程用C语言编程。



## 线性表

### 基本问题

**线性表的定义**   

K={k0, …, kn-1}，   R={(ki, ki+1) | ki, ki+1∈K, 0 ≤ i ≤ n-1}，  

#### **顺序存储**的线性表

采用**数组实现**线性表的顺序存储。  

数据定义 

```c
#define M 1000 
  int n;   /*  M>n     */ 
  int a[M];  /* a[0]~a[n-1]存放k0~kn-1 */
```

![image-20240621133252417](/img/wdz_jr_final/image-20240621133252417.png)

####  链接存储的线性表 

采用链表实现线性表的链接存储。  

数据定义 

```c
#define NODE struct node 
  NODE 
  { 
   int num;  /* 结点值ki   */ 
   NODE  *next;  /* ki+1的指针  */  
  }; 
```

根据操作的需要，可用**带哨兵或者不带哨兵**的链表存储线性表

### 查找结点

查找结点约定：已知某个结点的值为key。如果在线性表中找到该结点，查找成功， **返回结点的序号或者地址**。否则，查找失败。

#### 顺序查找算法

##### 顺序存储顺序查找算法

根据结点值key，在数组中逐个查询。如果查找成功，返回该结点的序号。如果查找 失败，**返回-1**。

**顺序存储**<u>顺序查找</u>的函数为 

```c
int searchS(int a[], int n, int key) 
{ 
 int i; 
 for(i=0; i<n; i++) 
  if(a[i] == key) 
   return(i);   /* 查找成功 */ 
 return(-1);    /* 查找失败 */ 
} 
 调用语句为： 
  i = searchS(a, n, key);
```

#####  链接存储顺序查找算法

根据结点值key，在链表中逐个查询。如果查找成功，返回该结点的地址。如果查找 失败，**返回NULL**。  

**链接存储**<u>顺序查找</u>的函数为 

```c
NODE *searchL(NODE *first, int key) 
{ 
 NODE *node; 
 for(node=first; node; node=node->next) 
  if(node->num == key) 
   return(node);  /* 查找成功 */ 
 return(NULL);   /* 查找失败 */ 
} 
 调用语句为： 
  node = searchL(First, key);   /* 无哨兵的链表 */ 
  node = searchL(Head->next, key);  /* 带哨兵的链表 */
```

#### 二分查找算法

二分查找算法(Binary Search，折半查找)**要求线性表已排序**。只能用**顺序存储方式**实 现，而**不适合链接存储**方式。  

##### 二分查找算法描述

假设线性表首结点和尾结点的下标分别为begin和end，  

即有序表为{k~begin~, k~begin~+1, ..., k~end~}。  

初始令begin=0，end=n-1。  

将线性表按中点一分为二，求mid=(begin+end)/2，  

比较中点k~mid~和待查找结点key的值：   

​	如果key==k~mid~，返回mid，查找结束。   

​	如果key<k~mid~，在有序表的左半段{ k~begin~, ...,k~mid~-1}继续查找。   

​	如果key>k~mid~，在有序表的右半段{ k~mid~+1, ..., k~end~}继续查找。   

​	如果begin > end，表示失败，查找结束。

##### 二分查找函数。

```c
int BiSearch(int *a, int n, int key) 
{  
     int begin=0, end=n-1, mid; 
     while(begin < end)  
        { 
         mid = (begin + end) / 2; 
         if(a[mid] == key)  /* 查找成功   */ 
             return(mid); //注意return(mid)的递归//
         else if(key > a[mid])  /* 改为右半段查找 */ 
             begin = mid + 1; 
         else if(key < a[mid])  /* 改为左半段查找 */ 
             end = mid - 1; 
        } 
     return(-1);    /* 查找失败   */ 
} 
调用语句为 
i = BiSearch(a, n, key); 
```

### 遍历操作

遍历操作的基本定义:**顺序或者逆序输出线性表中的所有结点**。  通常是指**顺序遍历**。 

####  顺序存储的线性表遍历函数

```c
void prtListS(int a[], int n) 
{ 
    int i; 
    for(i=0; i<n; i++) 
      printf("a[%d]=%d ", i, a[i]); 
    printf("\n"); 
} 
调用语句为 
	prtListS(a, n);
```

####  链接存储的线性表遍历函数

```c
void prtListL(NODE *first) 
{ 
     NODE *node; 
     for(node=first; node; node=node->next) 
          printf("node=%d ", node->num); 
     printf("\n"); 
} 
调用语句为 
prtListL(Fiirst);    /* 遍历无哨兵的链表 */ 
prtListL(Head->next);   /* 遍历带哨兵的链表 */
```

### 添加结点

#### 顺序存储添加结点

在当前结点k~i~的后面添加一个数值为key的新结点k’，  

使得 K = {k~0~, …, k~i~, k’, k~i+1~, …, k~n-1~}。  

添加结点的过程：   

**将a[n-1]到a[i]向数组尾部移动**，a[n]=a[n-1], a[n-1]=a[n-2], ..., a[i+1]=a[i]，  **腾出添加新结点key的位置a[i]，然后插入新结点key**，令结点数n加1。 

![image-20240621140821441](/img/wdz_jr_final/image-20240621140821441.png)

##### 添加结点的函数

```c
void addNodeS(int a[], int *n, int i, int key) 
{ 
     int j;   
     if(*n == M-1)       /* 数组溢出  */ 
      	error();
     if(i<-1 || i >(*n)-1)      /* 非法结点位置 */ 
      	error(); /* 如果i==-1，表示在线性表的前面添加结点 */ 
     for(j=(*n)-1; j>=i; j--)     /* 向表尾移动 */ 
      	a[j+1] = a[j]; 
     a[i] = key;       /* 添加新结点 */ 
     (*n)++;        /* 结点数加1  */ 
}
调用语句为 
addNodeS(a, &n, i, key); 
```

####  链接存储添加结点

如果在当前结点之前添加新结点，称为**前插入**。  

如果在当前结点之后添加新结点，称为**后插入**。  

**添加结点通常是前插入**操作。

![image-20240621141501825](/img/wdz_jr_final/image-20240621141501825.png)

由于可能**在线性表的表头前添加**结点，**推荐采用带哨兵的链表**。  

令当前结点的**前一结点的指针**为prev，则**当前结点的指针**为prev->next，**待添加的新结点指针**为node。  

通常将node指向的结点称为结点node。同理，可将prev->next指向的结点称为 prev->next。  

前插入的语句为   

node->next = prev->next;    //先将当前结点与新结点连接

prev->next = node;   //再更改前一结点的下一结点为新结点

图中用#表示指针值，表示prev->next指向当前结点。  

如果#为NULL，表示prev->next指向空，说明是在表尾插入结点(包括空链表的情况)。 

##### 前插入结点的函数

```c
void addNodeL(NODE *prev, NODE *node) 
{ 
     if(prev == NULL || node == NULL) 
      	error();   /* 链表不存在或者新结点不存在 */ 
     node->next = prev->next;    /* 添加新结点 */ 
     prev->next = node； 
} 
 调用语句形如： 
 addNodeL(prev, node); 
 如果prev==Head，表示在表前插入结点。 
 如果prev->next==NULL，表示在表尾插入结点。 
```

### 生成线性表

由此可以附上生成线性表函数

#### 顺序存储生成线性表

输入若干个数据，生成顺序存储的线性表。  

##### 生成顺序线性表的函数

```c
void createListS(int a[], int *n) 
  { 
   int  num;  
   *n = 0; 
   while(scanf("%d", &num) == 1) 
   	 a[(*n)++] = num; 
  } 
 调用语句为 
  createListS(a, &n);
```

#### 链接存储生成线性表

输入若干个数据，不断在表头前插入结点，生成链表。  

##### 生成链接线性表的函数

```c
NODE *createListL(NODE *first) 
  { 
  	NODE *node; 
    int  num;  
       while(scanf("%d", &num) == 1) 
       { 
            if( (node = (NODE *)(malloc(sizeof(NODE))) )== NULL) 
             	error();      /* 内存分配失败 */ 
            node->num = num; 
            node->next = first;    /* 表头插入  */ 
            first = node; 
       } 
       return(first); 
  } 
调用语句为 
   First = createListL(First);     /* 生成无哨兵的链表 */ 
   Head->next = createListL(Head->next);  /* 生成带哨兵的链表 */
```

### 删除结点

####  顺序存储删除结点

在数组a[]中找到待删除结点位置i(a[i]==key)。删除过程为：   

将a[i]**后面的所有结点**a[i+1]到a[n-]**向前移动，**   

a[i]=a[i+1]，a[i+1]=a[i+2], ..., a[n-2]=a[n-1]，令结点数减1。  

##### 顺序存储删除结点的函数

```c
void  deleteNodeS(int a[], int *n, int key) 
  { 
       int  i, k; 
       if((i = searchS(a, *n, key)) == -1)  /* 寻找待删除结点 */ 
        	error();      /* 待删除结点不存在 */ 
       for(k=i+1; k<(*n); k++) 
        	a[k-1] = a[k]; /*向前移动*/ 
       (*n)--; 
  } 
调用语句为 
  deleteNodeS(a, &n, key); 
```

####  链接存储删除结点

##### 删除指定地址的结点

删除由prev->next指向的待删结点，由node指向该结点(被删结点)。  删除结点的语句为：   

node = prev->next;    //取出待删除结点的地址

prev->next = node->next;   //连接删除结点的前结点和后结点

（可以不用取出待删除结点地址，直接连接结点前件和后件。但是将会丢失该节点的地址，造成内存泄漏。取出删除结点的地址是为了free掉）

如果不再需要使用被删结点，应该调用**free函数释放被删除结点的空间**：

##### 删除指定数值的结点

删除值为key的待删结点，由node指向并返回。  

###### 删除结点的函数

```c
NODE * deleteNodeL(NODE *prev, int key) 
{ 
    NODE *node; 
    for(node=prev->next; node; node=node->next) 
        if(prev->node->num == key) 
          {
            node = prev->next; 
            prev->next = node->next; 
            break; 
        }
     return(node); 
} 
调用语句为： 
node = deleteNodeL(Head, key);   
```

##  线性表排序算法

排序(或称分类)是**将线性表的所有结点按照指定的顺序排列**。

通常的排列顺序主要包括**升序关 系和降序关系**，升序排序后所有结点满足k~0~≤k~1~≤...≤k~n-1~，或者k~0~≥k~1~≥...≥k~n-1~。  

**已排序的线性表称为有序表**，记为S(Sorted)，**未排序的线性表称为无序表**，记为U(Unsort)。  

以下以升序为例介绍本课程需要掌握的五种排序算法:**插入排序法、选择排序法、冒泡排序法、快速排序法、合并排序法**。  

其中，除了**插入排序可以采用顺序存储或者链接存储**实现，**其他几种排序算法**通常算法**只能**用**顺序存储**方式实现，而不适合于**链接存储**方式。 

#### 插入排序算法

插入排序算法(insert sorting)是一种**最简单**的排序方法，也是**最基本**的排序算法。 

##### 顺序存储插入排序算法

###### 顺序存储插入排序算法的描述  
{% raw %}
定义K={{S}, {U}}，S = {a[0], a[1], …, a**[s-1]**}，U = {a**[s]**, a[s+1], …, a[n-1]}。  

初始设置：s=1。即S = {a[0]}，U = {a[1], a[2], …, a[n-1]}。  

**逐个将U中最前的结点a[s]插入到S中的适当位置**，使得**S=S+{a[s]}仍为有序表**，U=U {a[s]}，**直至U为空**为止
{% endraw %}


###### 每次将a[s]插入到S中的操作

(1) 暂存：令key = a[s]。 

(2) 移动和定位：按k=s, s-1, ..., 1的顺序，逐个比较key和a[k-1]。   

`	for(k=s; k>0 && key<a[s-1];k--)    `

​	`a[k] = a[k-1]; `

如果key>a[s-1]，表示a[s]将成为S的最大结点，a[s]为插入位置；  

**如果key<a[k-1]，则将a[k]向后移动一位**，即a[k] = a[k-1]。

否则，表示a[k-1]之前的结点**都不小于key，a[k]为插入位置**；  

其中，如果k==0，表示key将成为S的最小结点。 

(3) 插入：插入暂存结点key，令a[k]=key。

![image-20240621144348526](/img/wdz_jr_final/image-20240621144348526.png)

###### 顺序存储的插入排序函数insertS

```c
void insertS(int *a, int n) 
{ 
     int key, s, k; 
     for(s=1; s<n; s++) 
     { 
          key=a[s];      /* (1) 暂存  */  
          for(k=s; k>0 && key<a[k-1]; k--)  /* (2) 移动和定位 */ 
           	a[k] = a[k-1]; 
          a[k] = key;      /* (3) 插入  */ 
     } 
} 
调用语句： 
  insertS(a, n); 
```

##### 链接存储的插入排序

###### **链接存储插入排序算法的约定**

采用带哨兵的链表，由Head->next指向表头k~0~。  
{% raw %}
定义K={{S},{U}}，S为(已排序的)有序表，U为(未排序的)无序表。   

###### **链接存储插入排序算法的初始设置**

S={k~0~}，由`Head->next`指向。U=K - {k~0~}，由`unsort`指向。 
{% endraw %}
 程序语句为：   

`unsort = head->next->next;    `

`head->next->next = NULL; `

###### **链接存储插入排序算法的描述**

只要U非空，执行以下循环：  

(1) 摘除操作：摘除U的表头，由node指向，U = U - {node}。  程序语句为    

`node = unsort;    `

`unsort = node->next;`

(2) 定位操作：在S中找到node的插入位置  

程序语句为   

`for(prev=head; prev->next; prev=prev->next)    `

​	`if(node->num < prev->next->num)     `

​		`break;  `

表示**在S中寻找由prev->next指向的大结点**，由此**确定插入位置**。

**大结点**是指在S中搜索到的**第一个大于结点node的结点**。  

for循环的结束有以下几种可能：   

1. 如果prev->next == NULL，表示**node是最大结点**，结束循环。   

2. 如果prev->next != NULL && node->num < prev->next->num，    

   ​	表示**找到大结点**prev->next，跳出循环。

   ​	此时如果prev == Head，表示**node是最小结点**。

总之，将在prev->next之前插入node。 

(3) 插入操作：将node插入S，S = S + {node}。  

程序语句为   

`node->next = prev->next;   `

`prev->next = node; `

###### 链接存储的插入排序函数insertL

```c
void insertL(NODE *head) 
  { 
       NODE *unsort, *prev, *node; 
       if(head->next==NULL || head->next->next==NULL) 
        	return;      /* 空链表或者单结点链表  */ 
       unsort = head->next->next;   /* 初始：S = {k0}，U = K - {k0} */ 
       head->next->next = NULL; 
       while(unsort)      /* 只要U非空，循环   */ 
       { 
            node = unsort;         /* 摘除操作 */ 
            unsort = node->next; 
            for(prev=head; prev->next; prev=node->next)  /* 定位操作 */ 
            	 if(node->number < prev->next->number) 
             		 break;     /* 找到大结点，跳出循环 */ 
            node->next = prev->next;        /* 插入操作 */ 
            prev->next = node; 
       } 
  } 
调用语句： 
  insertL(a, n); 
```

##### 插入排序的算法复杂度

###### 顺序存储的算法复杂度

决定算法复杂度的程序语句为   

`  for(s=1; s<n; s++)   /* 插入n-1个结点  */ `
 	`   for(k=s-1; ...; k--) `

第二个for循环：   

​		插入第1个结点，最多移动1次；插入第2个结点，最多移动2次；   

​		插入第n-1个结点，最多移动n-1次。  

最多运算次数 = 1 + … + (n-2) + (n-1) = n^2^ / 2 ≈ n^2^  

因此，顺序存储插入的算法复杂度为O(n^2^)。 

###### 链接存储的算法复杂度  

决定算法复杂度的程序语句为   

`while(unsort)      /* 共需删除n-1个结点  */    `

​	`for(node=head; ...)  `

for循环：与顺序存储插入算法相同，  因此，链接存储插入的算法复杂度也为O(n2)。



#### 冒泡排序算法 

水中气泡受热后，所有气泡按浮力从大到小依次在水面冒泡，冒泡排序算法(bubble sorting)以 此得名。 

##### 冒泡排序算法的描述
{% raw %}
定义K={{U}, {S}}，U = {a[0], a[1], …, a[end]}，S = {a[end+1], …, a[n-1]}。  

初始设置：U = {a[0], a[1], …, a[n-1]}，S = 空。

从end=n-1开始，递减至end=1，实施n-1轮冒泡移动。   

​	从j=0开始，逐对比较U中两个相邻的数据：   

​	如果a[j]>a[j+1]，交换a[j]和a[j+1]，使较大的数据向后移动   

​	每一轮的冒泡移动使U中最大的数据成为S中最小的数据。  

例如，某一轮冒泡移动的效果为  

​	冒泡移动前： 3  2  8  6  7  4 [9]  

​	移动过程一： 2  <u>3</u>  8  6  7  4 [9]  

​	移动过程二： 2  3  6  <u>8</u>  7  4 [9]  

​	移动过程三： 2  3  6  7  <u>8</u>  4 [9]  

​	冒泡移动后： 2  3  6  7  4 [<u>8</u>  9]  

其中，粗体表示移动的数据，方括弧内外分别表示S和U的数据。

{% endraw %}

##### 冒泡排序函数bubbleA

```c
void bubbleA(int a[], int n) 
  { 
   int end, j; 
   for(end=n-1; end>0; end--)   /* 实施n-1轮冒泡移动 */ 
        for(j=0; j<end; j++)    /* 冒泡移动   */ 
         	if(a[j] > a[j+1])    /* 比较a[j]和a[j+1]  */ 
         	 	swap2(&a[j], &a[j+1]); /* 交换a[j]和a[j+1]  */ 
  } 
其中，swap2是交换两个数据的函数
调用语句： 
  bubbleA(a, n); 
```

##### 改进的冒泡排序算法

![image-20240621150430865](/img/wdz_jr_final/image-20240621150430865.png)

可以发现，第二轮后已经完成排序，后两轮没有发生数据交换，是多余的。如果在每一轮中 将最后一次数据交换的位置记为big，并且将确定冒泡交换循环轮次的end--改为end=big，就可以 改进冒泡排序算法，减少运行时间。 

#####  改进的冒泡排序函数bubbleB

```c
void bubbleB(int a[], int n) 
  { 
       int end, j, big; 

       for(end=n-1; end>0; end=big)  /* 把end更新为big  */ 
       { 
            for(big=j=0; j< end; j++) 
            if(a[j] > a[j+1]) 
            { 
             swap2(&a[j], &a[j+1]); 
             big = j; 
        	}
       } 
  }
```

##### 冒泡排序的算法复杂度

决定算法复杂度的程序语句为   

`for(end=n-1; end>0; end--)   /* 实施n-1轮冒泡移动  */   `

​	`for(j=0;j<end; j++)    /* 冒泡移动    */`

 第二个for循环：   

​	第1轮，最多移动n-1次；第2轮，最多移动n-2次，   

​	第n-1轮，最多移动1次。  

最多运算次数 = 1 + … + (n-2) + (n-1) = n^2^ / 2 ≈ n^2^ 

因此，冒泡排序的算法复杂度为O(n^2^) 

#### 选择排序算法

#####  选择排序算法(select sortng)的描述
{% raw %}
定义K={{S}, {U}}，S置于左侧，U置于右侧。  

初始设置：**S = 空**，U = {a[0], a[1], …, a[n-1]}。  

只要**U非空**，执行以下循环：   

​	每次**在U中选出一个最小的结点key=min(U)**，   

​	然后**将key与U中最前端结点交换**。   

​	令U = U - {key}，S = S + {key}。 
{% endraw %}
![image-20240621152821632](/img/wdz_jr_final/image-20240621152821632.png)

![image-20240621152831935](/img/wdz_jr_final/image-20240621152831935.png)

##### 选择排序函数select

```c
void select(int *a, int n) 
{ 
     int left, mini, i; 
     for(left=0; left<n-1; left++) 
     { 
        for(mini=left, i=left+1; i<n; i++) 
       		if(a[i] < a[mini]) 
       			mini = i;
        swap2(&a[left], &a[mini]); 
     } 
} 
调用语句： 
  select(a, n); 
    
```

#####  选择排序的算法复杂度 

决定算法复杂度的程序语句为  

`for(left=0; left<n-1; left++)  /* 选择n-1次  */`

​	`for(mini=left, i=left+1; i`

第二个for循环：   

​	插入第1个结点，最多比较n-1次；插入第2个结点，最多比较n-2次；   

​	插入第n-1个结点，最多比较1次。  最多运算次数 = 1 + … + (n-2) + (n-1) = n^2^/ 2 ≈ n^2^  

因此，选择排序的算法复杂度为O(n^2^)。

##### 注：选择排序与插入排序区别

插入排序将U中最前面的数据直接给S，接着在S中寻找合适的插入位置

选择排序先在U中寻找最小/大的数值，接着将最小/大的放到最前面，最后将这个最前面的直接并入S中

#### 快速排序算法

##### 快速排序算法(quick sorting)的描述 

定义线性表K = {a[L], a[L+1], …, a[R]}。  

初始设置：L = 0，R = n-1。  

**选择一个关键结点key**，通过结点的比较和移动，寻找某个合适位置，  

将K划分为{KL, key, KR}。**使KL中所有结点小于key，KR中所有结点大于key**。  

然后对KL和KR分别实施快速排序。  

当**所有划分的线性表中只有一个结点时，排序结束**。  

**关键结点key的选择**可以是线性表的首结点a[L]，尾结点a[R]，或者中点a[M]\(M=(L+R)/2))。 

本例选择中点a[M]为关键结点。 

![image-20240621154518741](/img/wdz_jr_final/image-20240621154518741.png)

其中，关键结点key用下划线表示，划分后落位的key用方括号表示。  

第2行到第5行表示在**左侧递归**排序。  

第6行到第7行表示在**右侧递归**排序。 

![image-20240621154834608](/img/wdz_jr_final/image-20240621154834608.png)

(关注几个点：

结束划分：从右向左搜索一定比从左向右搜索到的值索引大，当相等的时候说明可以结束划分了，将相等值的索引作为key放置地方的索引

交换左右搜索：先从左或者先从右，之后交换搜索方向

初始寻找key：从中点，并将其暂存为key)

个人觉得，从任何一个点都可以开始搜索，重要的是暂存该点的key并且获取该点的index

##### 快速排序函数quick

```c
void quick(int a[], int left, int right) 
{ 
     int L=left, R=right, M=(left+right)/2, key=a[M]; 
     if(left >= right) 
      	return; 
     while(L < R) 
     {  
          while(a[R] > key && L < R)  /* 从右查找小于key的结点  */ 
               R--;      /* 若a[R]>key，R递减   */ 
          if(L < R)      /* 找到a[R]<key    */ 
          { 
               a[M]= a[R];     /* 将a[R]移到a[M]，更新M  */ 
               M = R; 
          } 
          while(a[L] < key && L < R)  /* 从左查找大于key的结点  */ 
               L++;     /* 若a[L]<key，L递增   */ 
          if(L < R)      /* 找到a[L]>key    */ 
               a[M] = a[L], M = L;  /* 将a[L]移到a[M]，更新M  */ 
     } 
     a[M] = key;       /* 将key落位a[M]，完成划分 */ 
     quick(a, left, L-1);     /* 对UL递归执行快速排序  */ 
     quick(a, L+1, right);     /* 对UR递归执行快速排序  */ 
} 
 调用语句： 
  quick(a, 0, n-1); 
```

注意：初始化和递归的终止放到了开头。使用了while内两个while完成了一轮快速排序。最后进行调用左侧和右侧排序

##### 快速排序的算法复杂度

决定算法复杂度的程序语句为   

​	`	递归调用quick()   `

​	`	while(L < R)  `

递归调用quick()：   

​	平均情况，每次划分能够得到左右均匀的两个集合，划分的最多层数为log2(n)。   

​	最坏情况，每次关键点为最大值或者最小值，**划分的最多层数为n-1**。   

while循环：   

​	结点的比较次数最多为n-1次。  

因此，快速排序的算法复杂度为O(n^2^)。 

####  合并排序算法

#####  合并排序算法的表述  

合并排序算法(merge sorting，又称归并排序)包括两个函数。  

定义K = {a[0], a[1], …, a[n-1]}，令begin=0, end=n-1。  

(1) **合并排序函数(mergeSort)**是把线性表递归对半划分成两个序列，直至每个序列只含有1个 结点，然后调用**合并函数**完成排序。

合并排序函数的伪程序为：

```c
mergeSort(a, begin, end) 
  { 
       if(begin < end) 
       { 
            用中点把a划分为左右两端 
            对左端递归调用mergeSort() 
            对右端递归调用mergeSort() 
            调用merge()合并左右端 
       } 
  } 
```

(2) **合并函数(merge)**：合并两个有序表。 

![image-20240621161719682](/img/wdz_jr_final/image-20240621161719682.png)

##### 合并排序函数mergeSort()和merge()。

###### 合并排序函数mergeSort()

```c
void mergeSort(int *a, int begin, int end) 
  {   
       int mid; 
       if(begin < end) 
       { 
            mid = (begin + end) / 2; 
            mergeSort(a, begin, mid);    /* 左端递归  */ 
            mergeSort(a, mid+1, end);   /* 右端递归  */ 
            merge(a, begin, mid, end);   /* 合并有序表 */ 
       } 
  } 
```

![image-20240621161857401](/img/wdz_jr_final/image-20240621161857401.png)

用一个**if(begin < end)来做递归终结**

###### 合并函数merge()

```c
void merge(int *a, int begin, int mid, int end) 
  {      
       int b[M], i;, left=begin, right=mid+1 
       for(i=begin; i<=end; i++)  /* 复制a[]到b[] */ 
            b[i] = a[i];  
        for(i=begin; i<=end; i++) 
       { /* 选择b[]中较小数复制到a[]  */ 
        if(right > end)   /* ①如果右端数据已全部遍历，复制左端数据 */
            a[i] = b[left++];  
        else if(left > mid)   /* ②如果左端数据已全部遍历，复制右端数据 */ 
             a[i] = b[right++];  
        else if(b[left] < b[right]) 
             a[i] = b[left++]; /* ③复制左端数据 */ 
        else 
             a[i] = b[right++];  /* ④复制右端数据 */ 
       }  
  } 
 调用语句： 
  mergeSort(a, 0, n-1); 
```

![image-20240621162227471](/img/wdz_jr_final/image-20240621162227471.png)

理解：

首先，在begin-end的范围内，开了一个新的b数组，将范围内的a的值都给了b

其次，left=begin,right=mid+1,将数组分为两块

然后，比较左边块的left索引指向的值与右边块right索引指向的值，哪个小就先复制哪个到a里面（取决于想要降序还是升序）

最后，如果左边块的都放入了，那么直接让右边块剩下的直接放进去即可。（两个块都是已经排序好的）

#####  合并排序的算法复杂度

决定算法复杂度的程序语句为  

(1) 递归调用mergeSort()   对n个结点进行划分，**划分的最多层数为log2(n)**。  

(2) 调用merge()：    

​		for(i=begin; i<=end; i++)  /* 从a[]复制n个数据到b[] */    

​		for(i=begin; i<=end; i++)  /* 从b[]复制n个数据到a[] */   

​	两个for循环最多运算时间为2n。  

最多运算次数 = O(log2(n)) • (O(n) + O(n)) = O(n • log2(n))  

因此，合并排序的算法复杂度为O(n • log2(n))，记为O(nlog(n))，或者O(nlogn)。 

![image-20240621164319964](/img/wdz_jr_final/image-20240621164319964.png)

（注：根据看网上的，这个解释觉得更好。求递归相关的方程）

### 基本操作的算法复杂度

以结点数n为基数，各种排序算法的复杂度见下表。  

![image-20240621162428946](/img/wdz_jr_final/image-20240621162428946.png)

## 栈和队列

栈和队列是两种**特殊的线性表**，应用非常广泛。

### 栈

栈(stack，堆栈)是只能在栈顶添加结点或者删除结点的线性表。  

**栈的主要操作是push(进栈)和pop(出栈，退栈)。**  

进栈是指在栈顶添加一个结点，使原来的栈顶成为下一结点。  

出栈是从栈内取出栈顶结点，使原来的下一结点成为栈顶。  

在栈的操作过程中，最先进栈的结点将最后出栈。

栈又被称为**先进后出表(FILO表**，First In Last Out List)。



如果在满栈(栈容量已满)时进栈，称为**上溢出(overflow)。**  

如果在空栈(栈内没有结点)时出栈，称为**下溢出(underflow)。**  

在**程序实现时，必须处理上溢出和下溢出**的情况，以免出错。



栈的存储方式  

按照栈的存储方式，可以分为顺序栈和链接栈。  

通常用**数组来构造顺序栈，用链表来构造链接栈**。



### 顺序栈

#### 数据定义

```c
 #define M  1000 
 #define FULL M-1  /* 栈容量      */ 
 #define BTM 0  /* 栈底指针值    */ 
 int Stack[M];    /* 用数组存放栈    */ 
 int Top = BTM-1;   /* 栈顶指针，初始为空栈   */ 
```

#### 进栈函数push

```c
void push(int key) /* 结点值*/ 
 { 
      if(Top >= FULL   /* overflow  */ 
      || Top < BTM-1)  /* 非法指针值 */ 
       	error();  
      /* 结点进栈，指针加1 */ 
      Stack[++Top] = key; 
  }
  调用语句： 
  push(key); 
```



#### 出栈函数pop

```c
int pop(void) 
 { 
      if(Top < BTM  /* underflow  */ 
      || Top > FULL) /* 非法指针值 */ 
           error(); 
      /* 返回栈顶结点, 指针减1 */ 
      return(Stack[Top--]); 
 } 
 调用语句： 
  key = pop(); 
```

#### 设计多栈的讨论

设计一个栈，如果发生下溢出，表示程序有误，应该修改程序。  

如果发生上溢出，表示初始设计的栈容量太小，应该构造容量更大的栈。  

在实际应用中，可能在**一个软件中使用数据类型相同的多个栈**。 

如果在同一个数组中存放A栈和B栈两个栈，可以实现**同向双栈或者相向双栈**。

###### 同向双栈  

在同一个数组中同向存放A栈和B栈。  

![image-20240621165519995](/img/wdz_jr_final/image-20240621165519995.png)

满栈的处理：

![image-20240621165549069](/img/wdz_jr_final/image-20240621165549069.png)

###### 相向双栈 

使用A栈和B栈两个栈，在同一个数组中相向存放。  

![image-20240621165625284](/img/wdz_jr_final/image-20240621165625284.png)

能够自动调节，不需要移动A 栈或B栈。除非完全使用了所有容量，这时候需要开出更多的栈容量

### 链接栈

#### 数据定义

```c
#define  NODE  struct node 
 NODE 
 { 
      int  num; 
      NODE *next; 
 }；      /* 用链表存放栈   */ 
 NODE *Top = NULL; /* 栈指针，初始为空栈 */
```

#### 进栈函数push

```c
void push(int key) 
 { 
       NODE   *node; 
       node=(NODE *)malloc(sizeof(NODE)); 
       if(node == NULL) 
          error(); /* 满栈(overflow) */ 
       /* 填入结点数据 */ 
       node->num = key; 
       /* 插入结点  */ 
       node->next = Top; 
       Top = node; 
 } 
 调用语句： 
  push(key); 
```

#### 出栈函数pop

```c
int pop(void) 
 { 
      int  key; 
      NODE  *node; 
      if(Top == NULL) 
            error();  /* 空栈 */ 
      key = Top->num; 
      node = Top;  /* 删除结点 */ 
      Top = node->next; 
      free(node); /* 释放结点 */ 
      return(key); 
 } 
 调用语句： 
  key = pop();
```

#### 链接栈的应用：空栈管理

在进栈函数push()中需要调用malloc()申请空间，出栈函数pop()中需要调用free()释放空间。  

**反复调用malloc()和free()，实际上是增加了与系统打交道的时间**。如果次数频繁，将降低程 序的运行速度。  

通常在实际软件开发中可以**采用以下空栈管理**的办法： 

(1) 需要使用结点时从空栈取出结点(空栈出栈)。   

如果尚未建立空栈或者空栈内的结点已取完，则集中申请一批存储单元，存入空栈。 

如果申请动态空间失败，出错处理。  

(2) 结点用完后将结点放回空栈(空栈进栈)，从而提高软件的效率。  

修改链接栈的进栈函数和出栈函数中的相关语句如下：  

将进栈函数中申请空间的语句   

`if( ( node=(NODE *)malloc(sizeof(NODE)) ) == NULL)    `

​		`error();  `

改为：`   node= popFree());  `

其中，动态申请空间的测试任务由popFree()函数去处理。  

将出栈函数释放空间的语句   

`free(node);  `

改为：  ` pushFree(node); `

###  栈的应用：函数递归调用

递归栈的**特点**表现为：  

**递归调用函数时，保护递归现场：**系统将构造一个由参数表(调用函数时的所有数据)和函数的调用位置(返回地址)组成的活动记录，实施递归栈进栈，然后执行被调函数。  

**被调函数返回时，恢复递归现场**：获取栈中的活动记录，并根据参数表的信息，从调用位置向下继续执行当前函数。

递归栈中记录了递归调用时保留的现场，即函数 的调用位置和调用时函数内的所有数据。



栈的应用示例：PFE的计算 

栈的应用示例：SAE的计算 

(个人觉得：如果算法有明显的数据进出，则说明可以用进出栈)

### 队列

队(queue，队列)是**只能添加终结点和删除始结点**的线性表。  

队的**始端称为队首**，队的**终端称为队尾**。  

队的**主要操作包括enqueue(进队)和dequeue(出队)**。



**进队是在队尾添加一个新结点**。  

**出队是取出队首结点**，并使原来的下一个结点成为队首。  

在队的操作过程中，最先进队的结点必定最先出队。  

因此，队又被称为**先进先出表**(FIFO表，Fist In Fist Out List)。  

如果在满队(队容量已满)时进队，称为**上溢出(overflow)**。  

如果在空队(队内没有结点)时出队，称为**下溢出(underflow)**。  

在程序实现时，**必须处理上溢出和下溢出**的情况，以免出错。



**队的存储方式**

按照队的存储方式，可以分为顺序队和链接队。  

通常用**数组来构造顺序**队，用**链表来构造链接**队。



#### 顺序队列

##### 数据定义

```c
#define M  100 
#define FULL M-1   /* 队尾指针的最大值   */ 
#define BTM 0  /* 队首指针的最小值  */ 
#define EMPTY -1  /* 空队指针值   */ 
int Q[M];    /* 用数组存放队列  */ 
int Head = EMPTY;   /* 队首指针，初始为空队 */ 
int Tail = EMPTY;   /* 队尾指针，初始为空队 */ 
```

![image-20240621172430069](/img/wdz_jr_final/image-20240621172430069.png)

#####  顺序队列的出队操作

出队操作要处理三种情况：

下溢出、出空和正常出队。  

**下溢出**的判据为Head或者Tail等于EMPTY。  

**出空**表示单结点队列出队，判据为Head等于Tail而且均大于EMPTY。其操作是返回 Q[Head]，然后将Head和Tail都置为BTM。  

**正常出队**表示队内有多个结点，判据为Head小于Tail而且大于EMPTY，其操作是返回队首结点Q[Head]，然后令Head加1。 

##### 顺序队列的出队函数deQueue

```c
  int deQueue(void) 
  { 
       int key; 
       if(Head == EMPTY || Tail == EMPTY) /* 下溢出  */ 
            error(); 
       key = Q[Head];      /* 获取队首  */ 
       if(Head == Tail) 
            Head = Tail = EMPTY;    /* 出空   */ 
       else 
            ++Head;       /* 正常出队  */ 
       return(key);  
  } 
 调用语句： 
  key = deQueue(); 
```

##### 顺序队列的进队操作

进队操作要处理四种情况：

上溢出、空队进队、假溢出和正常进队。  

**上溢出**的判据为Tail等于FULL而且Head等于BTM。 

**空队进队**判据为Head等于EMPTY，其操作是令Head和Tail都置为BTM，然后将key赋给 Q[Tail]。  

(注意空队进队，对Head和Tail都+1了，而正常进队是对Head不操作的)

**假溢出是队未满而队尾方向无空间**，判据为Tail等于FULL而且Head大于BTM，其**操作是将所有 结点向队首方向平移，然后实施进队操作**。  

**正常进队**判据为Tail小于FULL而且Head大于等于BTM，其操作是令Tail加1，然后将key 赋给Q[Tail]。



##### 顺序队列的进队函数enQueue

```c
void enQueue(int key) 
  {  
       int k; 
       if(Head<EMPTY || Head>FULL || Tail<EMPTY || Tail>FULL) 
            error( );        /* 非法   */ 
       if(Tail == FULL && Head == BTM)  /* 上溢出  */ 
            error(); 
       if(Tail == FULL && Head > BTM)  /* 假溢出  */ 
       { 
            for(k=Head; k<=FULL; k++)   /* 平移   */ 
                 Q[k-Head] = Q[k]; 
            Tail = Tail - Head;     /* 更新指针  */ 
            Head = BTM; 
       } 
       else if(Head == EMPTY)      /* 空队进队  */ 
            ++Head;       /* 更新指针  */ 
       Q[++Tail] = key;      /* 进队   */ 
       return; 
  } 
  调用语句： 
  enQueue(key);
```

顺序队列的进队和出队，使得整个队列将不断向队尾方向移动。每当**进队遇到假溢出**，就需要 将整个队列向队尾平移。在极端情况下，如果在满队时不断交替地出队和进队，就需要**频繁地平移 队列**。显然，这种**费时的平移是顺序队列的致命弱点**。

#### 环形队列

环形队列(Circle Queue，循环表)是解决顺序队列假溢出问题的替代方案。  

在环形队列中，把Q[0]视为Q[M-1]的下一元素，将数组的首尾相连组成环状。  

在进队和出队时**把队首指针Head或队尾指针Tail加1的操作，改为(Head+1)%M或者 (Tail+1)%M**。 

![image-20240621173125707](.//img/wdz_jr_final/image-20240621173125707.png)

##### 环形队列的进队函数enCirQueue和出队函数deCirQueue

```c
#define M  100 
#define FULL M-1     /* 队尾指针的最大值  */ 
#define EMPTY -1    /* 空队指针值   */ 
int Q[M];       /* 用数组存放队列  */ 
int Head=EMPTY;     /* 队首指针，初始为空队 */ 
int Tail=EMPTY;      /* 队尾指针，初始为空队 */ 
void enCirQueue(int key) 
{ 
     if((Tail + 1) % M == Head)    /* 上溢出  */ 
          error( ); 
     Tail = (Tail + 1) % M; 
     if(Head == EMPTY)      /* 空队进队  */ 
          Head = Tail;   
     Q[Tail] = key;       /* 进队   */ 
} 
int deCirQueue(void) 
{ 
     int key; 
     if(Head == EMPTY)     /* 下溢出  */ 
          error( ); 
     key = Q[Head];
     if(Head == Tail)      /* 出空   */ 
          Head = Tail = EMPTY; 
     else         /* 正常出队  */ 
          Head = (Head + 1) % M; 
     return(key); 
} 
函数调用语句形式如下： 
enCirQueue(key); 
key = deCirQueue();
```

### 链接队列

#### 链接队列的设计  

本例采用**无哨兵的链表**实现链接队列，并且采用**空栈技术**。  

用空栈操作函数pushFree从空栈获得结点空间，并且处理上溢出的情况。  

用pushFree函数向空栈释放结点空间。

#### 数据定义

```c
#define   NODE  struct node 
 NODE  
 { 
      int num; 
      NODE *next; 
 }; 
 NODE  *Head = NULL;   /* 队首指针，初始为空队 */ 
 NODE  *Tail = NULL;   /* 队尾指针，初始为空队 */ 
```

#### 链接队列的进队函数enQueue

```c
void enQueue(int key) 
  { 
       if(Tail == NULL)   /* 空队进队 */ 
            Head = Tail = popFree();  
       else      /* 正常进队 */  
            Tail = Tail->next = popFree(); 
       Tail->num = key;    /* 结点进队 */ 
       Tail->next = NULL;   /* 更新队尾 */ 
  } 
 调用语句： 
  enQueue(key); 
```

#### 链接队列的出队函数deQueue

```c
int deQueue() 
  { 
       NODE *node; 
       int  key; 
       if(Head == NULL)  /* 下溢出  */ 
            error(); 
       key = Head->num;  /* 获取结点值 */ 
       node = Head;   /* 删除队首结点 */ 
       Head = Head->next; 
       pushFree(node);   /* 释放队首结点 */ 
       if (Head == NULL) /* 出空   */ 
           Tail = NULL; 
       return(key);    /* 返回结点值 */ 
  } 
 调用语句： 
  key = deQueue();  
```

### 双向队列(双向栈)

如果将栈和队列的特点结合在一起，**使得在线性表的两端都可以进行添加结点和删除结点的操 作**，这种线性表称为**双向队列或者双向栈**(deque，double-ended queue)。  

这种数据结构在C++中称为**容器**。

![image-20240621174936971](/img/wdz_jr_final/image-20240621174936971.png)

## 树

### 树的定义

#### 定义  

树是由若干个结点组成的数据结构，满足以下两个条件：  

(1) 树中有且仅有一个始结点，称为根结点(root，简称根)。  

(2) 除了根结点以外的所有结点分成m(m≥0)个互不相交的集合{T1, T2, …, Tm}，   

Ti(i=1,..., m)是根结点的子树(subtree)

####  树的结点及图形表示

结点的后件称为子结点。**子结点及其以下的结点**称为**子辈结点**。  

结点的前件称为父结点。**父结点及其以上的结点**称为**父辈结点**。  

没有子结点的结点称为**叶结点(leaf)**。

除了根和叶以外的结点称为**内结点**。  

树的图形表示是将根结点放在最高处，子树在它下面，形如一棵倒置的树。用**无向线段连接**结 点及其子结点。

#### 树的特性

如果树中**最多的子结点数为n**，这种树称为**n次树**。  

如果所有结点的子结点数**要么等于n要么等于**0，这种树称为**n次完全树**(complete tree)。  

给每个结点都定义一个层号，规定根的层号为1，它的子结点的层号为2，并依次类推。 

### 树的存储形式

树是一种非线性的数据结构，它不能简单地用一维数组或者用单指针的链表来存储树。  

(1) **标准形式**  

n次树的标准存储形式是**为结点k设置n个指针**{p1k, …, pnk}，**指针pik指向第i个子结点**。  用标准形式存储图示三次树的存储单元。其中结点地址为虚构值，φ表示空地址。

![image-20240621175409478](/img/wdz_jr_final/image-20240621175409478.png)

(2) **逆形式**  

树的逆形式是为结点k设置一个指针p0k，指向其父结点。  用逆形式存储图示三次树的存储单元。其中只有根结点的指针指向空。  

(3) 标准扩充形式  

树的标准形式和逆形式组合在一起，可构成树的标准扩充形式。

####  标准形式存储的数据设计

用一维数组、一维动态数组和链表等不同方式定义**结点的存储**。

用一维数组、一维动态数组、链表和多指针等不同方式定义**结点指针的存储**。

采用一维数组或者动态数组存储结点时，**用n表示结点数**。

采用一维 数组或者动态数组存储指针时，**用m表示子结点数**。

![image-20240621194446480](/img/wdz_jr_final/image-20240621194446480.png)

横轴代表所有结点的存储形式，区别在于变量定义上

对于一维数组存储结点，是一个TREE数组

对于动态数组存储，是一个TREE数组的头指针

注意：对于链表存储结点，需要多一个next，这是链表必须有的，无关树

纵轴代表如何寻找到子节点，

如果是一维数组，则子节点的地址/索引都在一个数组里面

如果是动态数组，则只需要动态数组的0的地址，其他的子结点地址通过\*(p+1)的方式找到

如果是链表形式，则通过遍历链表找到想要的地址

注意：对于动态数组形式，需要多一个m，用在申请子节点的指针数组时

####  数据存储空间的设计

数据量已确定，表示在程序运行之前就已知道。   

数据量可确定，表示可在程序运行过程中获知，包括外部输入或者通过计算而得。   

数据量不确定，表示无法预料数据量的范围。

![image-20240621201417241](/img/wdz_jr_final/image-20240621201417241.png)

#### 指针设计

![image-20240621201508494](/img/wdz_jr_final/image-20240621201508494.png)

### 树的遍历

#### 树的基本操作  

查找： 查找某个结点，父辈结点，或子辈结点。  

遍历： 按某种方式逐个访问全部结点或具有某种特征的结点。  

添加： 添加结点或添加子树。  

删除： 删除结点或删除子树。  

构造： 按一定要求生成树。  

排序： 按某种顺序排列结点。 

#### 树的遍历方式

树的遍历是树的基本操作，是指指按照某种规 律，逐个访问树中的全部或者部分结点。  

树的遍历包括以下各种方式：  

 前序遍历   后序遍历   层次遍历   结果遍历

（相关遍历的汉语解释略，看递归方法就懂了）

### 树的线性表示和生成 

#### 树的括号表示

如果树T只有一个结点，此结点就是它的括号表示。  

如果树T由根结点R和子树T1, T2, …, TM组成，则树T的括号表示就是

R(T1的括号表示, T2的括号表示, …, TM的括号表示)。 

**括号**：表示根和子结点  

括号左边为根，括号内为子结点。

 **逗号**：表示同辈结点  同辈结点之间用逗号分隔。  

####  树的层号表示

按某种遍历写出树中全部结点，并在结点之前注明其层号。  

对树中的每一个结点k 规定一个正整数Lev(k)，满足：   

​		对于根结点k0， Lev(k0) = 1；   

​		**如果k’是k的后件，则 Lev(k’) = Lev(k) + 1；**   

​		如果k’与k”是同一结点k的后件，    则 Lev(k’)=Lev(k”)。 

#### 树的生成示例

根据**后序遍历层号表示**生成树，需要使用一个栈。  

用(Lev Key)表示输入结点Key的层号和结点值，  

用(Ls Ks)表示栈顶结点Ks的层号和结点值。

```c
  读取(Lev Key)进栈 
  while(读取node(Lev Key) != 空) 
  { 
   while(栈非空 && Ks是Key的子结点：Lev+1 == Ls)
   {
       (Ls Ks)出栈 
       用Key链接子结点Ks 
   } 
   if( Key不是根：Lev != 1) 
        (Lev Key)进栈 
   else 
        生成以Key为根的树，结束 
  } 
  if(栈非空) 
       出错 
 
```

进栈出栈+while，实现抽象化数据结构算法

注意外层while和内层while的结束条件。外层while对数据逐个处理并决定是否进栈，内层while实现将所有栈内数据出栈并逐个做处理

## 二叉树

### 二叉树的定义

**n次树和二叉树可以相互转换，因此n次树可以采用二叉树的存储形式**。  

规定二叉树结点的**第一后件称为左子**(左后件，左件)，**第二后件 称为右子**(右后件，右件)。  

二叉树的结点可以既有左子又有右子，也可以只有左子，或者 只有右子，甚至没有后件。  

### 二叉树的遍历

采用二叉链表存储二叉树。  

在链表中定义左子指针left和右子指针right。

数据定义 

```c
#define TREE struct tree 
TREE 
{ 
 char  key;   /* 约定结点值为单个字符 */ 
 TREE *left, *right; 
}； 
TREE * Root;  /* 根结点 */
```

二叉树前序遍历的递归函数

```c
void preOrder(TREE *node) 
{ 
     if(node == NULL) 
          return; 
     printf("node = %c\n", node->key);  /* 首先访问根    */ 
     preOrder(node->left);    /* 然后按前序遍历根的左子树 */ 
     preOrder(node->right);   /* 再按前序遍历根的右子树 */ 
} 
 调用语句： 
  preOrder(Root);
```

二叉树后序遍历的递归函数 

```c
void postOrder(TREE *node) 
{ 
     if(node == NULL) 
          return; 
     postOrder(node->left);    /* 首先按后序遍历根的左子树 */ 
     postOrder(node->right);    /* 然后按后序遍历根的右子树 */ 
     printf("node = %c\n", node->key);  /* 再访问根     */ 
} 
 调用语句： 
  postOrder(Root);
```

二叉树中序遍历的递归函数 

```c
void symOrder(TREE *node) 
{ 
     if(node == NULL) 
          return; 
     symOrder(node->left);    /* 首先按中序遍历根的左子树 */ 
     printf("node = %c\n", node->key);  /* 然后访问根    */ 
     symOrder(node->right);   /* 再按中序遍历根的右子树 */ 
} 
 调用语句： 
  symOrder(Root); 
```

**重要！！！！**

**注意两个递归顺序与中间插入的`printf`等，可以将`printf`替换为其他函数，也可以对递归进行一些条件限制，但是大致的框架和递归顺序针对特定的遍历方法是固定的**

二叉树的**层次遍历**是一个非递归的算法，需要使用一个**队列**。

其算法是：首先将根结点进队。然后，只要队非空，出队结点并访问该结点，它的左右子进队。 直到队列为空时结束遍历过程。

```c
void levOrder(TREE *node) 
{ 
     if(node == NULL) 
          return; 
     enQueue(root);       /* 根结点进队  */ 
     while(node = deQueue())    /* 只要队非空，循环 */ 
     { 
          printf("node = %c\n", node->key);  /* 访问结点   */ 
          if(node->left) 
               enQueue (node->left);   /* 左子进队   */ 
          if(node->right) 
               enQueue (node->right);   /* 右子进队   */ 
     } 
} 
调用语句如下： 
levOrder(Root); 
```

队列可以实现自少向多抽象化扩展，递归只能实现自多向少抽象化扩展

### 二叉树的线性表示和生成

#### 二叉树的层号表示  

二叉树的层号表示与n次树的层号表示方法相同。 

#### 二叉树层号表示的唯一性问题

一个结点的前序遍历后件可为左子，也可为右子。  

一个结点的后序遍历前件可为左子，也可为右子。

因此，**前序遍历和后序遍历的层号表示都不能唯一地确定一棵二叉树**。 

一个结点的**中序遍历前件**必定是其左子。  一个结点的**中序遍历后件**必定是其右子。

**中序遍历的层次表示必能唯一地确定一棵二叉树**。  

此外，**二次完全树前序遍历和后序遍历的层次表示都能够唯一地确定一棵二叉树**。

####  二叉树的括号表示

二叉树的括号表示，是指二叉树前序遍历的括号表示。  

如果二叉树T由根结点R和左子树TL和右子树TR组成，则树T的括号表示为：   

R(TL的括号表示, TR的括号表示)   或者   R(TL的括号表示, )  或者   R(, TR的括号表示)  或者   R 

二叉树的括号表示可以**唯一地**确定一棵二叉树。

#### 根据括号表示生成二叉树

(1) 编写生成二叉树的函数`MakeBitree()`。  

(2) 编写生成子树的递归函数`MakeNode()`。  

(3) 编写其他辅助函数。

`MakeBitree()`：生成二叉树。

生成根结点，递归调用`MakeNode()`生成子树。

##### ` MakeNode()`：生成并存储结点

 按“(左子树, 右子树)”的格式，  

调用`GetKey()`和`GetSymbol()`获取结点值和有效符号。  

调用`newNode()`生成结点，调用`MakeNode()`生成左右子树。 

```c
void MakeNode(NODE *root) 
 { 
     char key[10]; 
     if(!GetSymbol('('))     /* 1. 获取左括号'('  */ 
          return; 
     if(GetKey(key))     /* 2. 获取左子数据 */ 
     {   
          root->left = newNode(key);  /* 2.1 生成左子空间 */ 
          MakeNode(root->left);   /* 2.2 递归生成左子树 */ 
     } 
     if(!GetSymbol(','))     /* 3. 获取逗号','  */ 
          error("missing , !");  
     if(GetKey(key))     /* 4. 获取右子数据 */ 
     {   
          root->right = newNode(key);  /* 4.1 生成右子空间 */ 
          MakeNode(root->right);   /* 4.2 递归生成右子树 */ 
     } 
     if(!GetSymbol(')'))     /* 5. 获取右括号')'  */ 
          error("missing ) !");  
     if(root->right == NULL && root->left == NULL)
          error("no node !");    /* 无左右子，出错 */  
 } 
```

#### 根据二叉树的遍历生成二叉树  

如果已知二叉树的前序和中序遍历，可以唯一地确定二叉树。  

如果已知二叉树的后序和中序遍历，可以唯一地确定二叉树。

**根据前序和中序遍历生成二叉树的程序示例**

生成二叉树的算法表述：  

(1) 由于**根是前序的首结点，可确定根为p1**，同时可在中序中找到sR=p1。   

例如：A是根。在前序中p1=‘A’，在中序中s4=‘A’。  

(2) 根据**中序，根的前面是左子树，后面是右子树**。   

可将中序划分为{SL, 根(=s~R~), SR}，其中，   

SL={s1,...,s~R-1~}和SR={s~R+1~,...,s~n~}分别表示左右子树的中序结点。

(3) 根据**中序划分，可将前序划分**为：

{根(=p1), PL, PR}，其中，   

PL={p~2~,...,p~R-1~}和PR={p~R~,...,p~n~}分别表示左右子树的前序结点。   

SL与PL的结点相同，SR与PR的**结点相同，但顺序可以不同**。 

(4) 从而**分别获得左右子树的前序和中序**。   

(5) 由此**递归处理**，直到**子树只有一个结点或为空，完成二叉树的拼接**。



### 二叉树的约定顺序存储

严格地说，**二叉树不能采用顺序存储，或者说不能直接用数组存储二叉树**。 

任何一种遍历都是一种线性关系。如果**利用二叉树的遍历特性和约定的数组下标**，可以只设置 一个指针，实现约定的数组存储，包括前序、中序以及后序顺序存储。 

例如，在一个数组中按**前序遍历存储**所有结点，根结点必定是数组的首元素。一个结点如果有 左子，左子必定是该结点的前序遍历后件，因此不需要存储左子的地址，**只要约定指针值说明结点 是否有左子或者右子，并且存储右子的地址即可**。 

#### 二叉树前序遍历顺序存储示例

约定用用Tree[1]到Tree[n]存储各结点，用**Tree[0].pk存储结点数n**。  

用数组下标k，pk~L~和pk~R~分别表示结点及其左右子的地址。 

![image-20240621211144210](/img/wdz_jr_final/image-20240621211144210.png)

后序遍历函数 

```c
void postOrder(BITREE tree[], int k) 
{ 
     if(tree[k].pk > 0) 
          postOrder(tree, k+1);    /* 按后序遍历左子树 */ 
     if(ABS(tree[k].pk) > 0 && ABS(tree[k].pk) < tree[0].pk+1)  
          postOrder(tree, ABS(tree[k].pk)); /* 按后序遍历右子树 */ 
     printf("%c ", tree[k].key);  
} 
调用语句： 
postOrder(Tree, 1); 
printf("\n");  
```

### n次树到二叉树的转换 

####  n次树到二叉树的图形转换方法

对任一结点，保持对第一子结点的指向不变，把对其他子结点的指向改为从第一子结点起同辈 中前一结点出发的水平指向。  将所有的水平指向顺转45度，就可得到转换后的二叉树。 

#### n次树到二叉树的转换方法 

n次树到二叉树的转换方法又称为左孩子右兄弟转换方法。  

n次树中的所有结点k，都含有m(≤n)个子结点{k1, k2, …, km}。  

转换算法的表述：  

从根开始，按前序遍历方式访问所有结点k。  

将k1作为k的左子(左孩子)，将结点ki(i=2, …, m)依次作为结点ki-1的右子(右兄弟)。

##### 三次树到二叉树的转换程序

```c
#define  TRINODE  struct  trinode 
 #define  BINODE    struct  binode 
 TRINODE  
 { 
  char key; 
  TRINODE  *sub1, *sub2, *sub3; 
 };  
 BINODE 
 { 
  char key; 
  BINODE *left, *right; 
 }; 
 TRINODE *RootT=NULL;  /* 三次树的根指针 */ 
 BINODE  *RootB=NULL;  /* 二叉树的根指针 */ 
 BINODE  *T2B(TRINODE *t) 
 { 
      BINODE    *b; 
      if(t == NULL)  /* 空结点，返回 */ 
           return(NULL); 
      if( (b=(BINODE *)malloc(sizeof(BINODE))) == NULL ) 
           error();    
      b->key = t->key;       /* 复制结点值 */ 
      b->left = b->right = NULL;    /* 左右子置空 */ 
      if(t->sub1) 
      {   
           b->left = T2B(t->sub1);   /* 转换第一子树 */ 
           if(t->sub2) 
           { 
                b->left->right = T2B(t->sub2); /* 转换第二子树 */ 
                if(t->sub3) 
                     b->left->right->right = T2B(t->sub3); /* 转换第三子树 */ 
           } 
      } 
      return(b); 
 } 
调用语句： 
 RootB = T2B(RootT); 
```



### 穿线树 

在标准形式存储的二叉树中，n个结点共有2n个指针。

因为根结点没有前件，其他每个结点只 有一个父结点，共有n-1个指针非空，而n+1个指针为空。

可视为一种浪费，为此引入**穿线树的概 念**。  

利用空闲指针形成穿线树的方法   对**空闲的左子指针，作为穿线指针，指向其中序前件**。   对**空闲的右子指针**，作为穿线指针，指向其**中序后件**。  这样**只有两个指针指向空，一个为中序始结点，另一个为中序终结点**。  用虚线表示穿线指针的指向，以区别于二叉树前后件的指针。

![image-20240621212917778](/img/wdz_jr_final/image-20240621212917778.png)

#### 利用穿线树实现二叉树的遍历程序

##### 数据定义 

```c
#define  M  100 
  #define TH struct thread 
  TH 
  { 
       char key[10]; 
       int left, right; 
  }; 
 TH th[M]; 
 int Root;    /* 根地址 */ 
 int n;    /* 结点数 */
```

按标准形式用结构数组存储穿线树。  用`th[k](k=1,...,n)`存放n个结点。**用0表示空地址**。  

**穿线指针值**(中序前件或者中序后件的地址)用**负数**

![image-20240621213247282](/img/wdz_jr_final/image-20240621213247282.png)

#####  求取结点中序前件地址的函数

```c
int getPre(TH *th, int i) 
  { 
       if(i<1 || i>n)     /* 非法地址 */ 
            error(); 
       if(th[i].left == 0)   /* 无左子  */ 
            return(0); 
       if((i = th[i].left) > 0)   /* 有左子  */ 
            while(th[i].right > 0) /* 有右子  */ 
             	i = th[i].right; 
       return(ABS(i)); 
  } 
 调用语句： 
  k = getPre(th, i);
```

如果有左子，需要继续查询该左子的右子，直到找到距离给的结点最近的左边结点，为中序前件

（很妙的地方在于：如果没有右子，会得到一个负数i，而我们返回一个i的绝对值）

（注：此外还有很多示例代码，此处略）

### 哈夫曼树(最优二叉树)

####  最优二叉树的应用

编码问题：如何使编码总长度最短?

#### 最优二叉树

对二叉树的每个叶结点给定一个**权值W~k~**，从根结点到各叶结点的**路径长度L~k~与结点的权值W~k~乘 积之和**叫做二叉树的**带权路径长度(WPL，权路径长度)**。
$$
WPL=\sum_{k=1}^n Wk\ \times\ L_k
$$
**WPL最小的完全二叉树称为 最优二叉树(哈夫曼树，Huffman Tree)**。

构造哈夫曼树的的策略可以是： 

(1) 升序策略：对任一结点，左子的权值≤右子的权值。  

(2) 降序策略：对任一结点，左子的权值≥右子的权值。

#### 哈夫曼树生成和编码程序

哈夫曼树构造算法  

初始，升序排序的叶结点集合为H = {w1, w2, …, wn| wi 1)  

每个叶结点都可以视为一棵以wi为根的子树。

while(n > 1) 

​	在H中删除{w1, w2}。  

​	合并：构造以w’(= w1+w2)为根，w1和w2为左右子的子树。  

​	然后将w’按升序插入H。  从而获得哈夫曼树。 

(注：在算法实现上，其实是一个H作为链表，链表中每个块有一个指针，指向另一个链表的地址node)

![image-20240621214842900](/img/wdz_jr_final/image-20240621214842900.png)

得到哈夫曼树之后对边进行0/1编码即可得到哈夫曼编码

![image-20240621215033106](/img/wdz_jr_final/image-20240621215033106.png)

哈夫曼编码(Huffman码)是一种不等长的前缀编码，其特征是没有一个编码是另一个编码的前缀， 使得解码时不会混淆。

求取WPL：

![image-20240621215103040](/img/wdz_jr_final/image-20240621215103040.png)

报文的哈夫曼编码总长度：   WPL = 8×1 + 5×2 + 2×3 + 4×3     = 36

### 二叉搜索树

#### 二叉搜索树的定义

二叉搜索树(BST, Binary Search Tree)中所有结点的值是唯一的(所有结点值不相同)。  任何结点的值大于其左子树中的所有结点值，小于其右子树中的所有结点值。  

二叉搜索树的**中序遍历是升序排序**的。

####  二叉搜索树的投影特性

二叉搜索树的投影效果，等同于获得中序遍历的升序排序。  

二叉搜索树的投影步骤如下：   

(1) 将所有左子树中的结点都画在结点的左下方   

(2) 将所有右子树中的结点都画在结点的右下方   

(3) 然后垂直投影

![image-20240621215303138](/img/wdz_jr_final/image-20240621215303138.png)

#### 二叉搜索树生成程序

结点插入函数`insertNode() `:重要！！！:kissing_smiling_eyes:

```c
void insertNode(BST *root, BST *node) 
  { 
       if(node->key == root->key) 
            error();      /* 结点已存在，插入失败 */ 
       else if(root->left != NULL && node->key < root->key) 
            insertNode(root->left, node);   /* 左查找插入 */ 
       else if(root->right != NULL && node->key > root->key) 
            insertNode(root->right, node);   /* 右查找插入 */ 
       else if(root->left == NULL && node->key < root->key) 
            root->left = node; ;      /* 左插入操作 */ 
       else if(root->right == NULL && node->key > root->key) 
            root->right = node;      /* 右插入操作 */ 
  } 
```

注意这里的if判断逻辑，会从root开始一直递归查找，直到到达叶节点。

 生成结点函数`makeNode() `

```c
BST *makeNode(int key) 
  { 
       BST *node; 
       if((node = (BST *)malloc(sizeof(BST))) == NULL) 
            error(); 
       node->key = key; 
       node->left = node->right = NULL; 
       return(node); 
  } 
```

####  删除结点

删除一个结点node，包括两个步骤：  

(1) 定位：查找并确定node的位置。  根据结点值key，找到由其父结点(记为root)指向的结点root->left或者root->right。 

(2) 替代：删除结点node  为保持二叉搜索树的特性不变，可采用多种方案。  

以下**采取考察node左子树的方案来删除结点**，并且分为以下**三种情况**。

 case1：node无左子  

表示node的子树中无中序前件，则用其右子替代node。  

操作语句为：   `root->L/R = node->right;`  以下图中带箭头的实线线段代表改变的指针。 

![image-20240621220714655](/img/wdz_jr_final/image-20240621220714655.png)

case2：node的左子无右子  表示node的左子就是其中序前件，则用其左子替代node。  操作语句为：   

`node->left->right = node->right;   `

`root->L/R = node->left;`

![image-20240621220748292](/img/wdz_jr_final/image-20240621220748292.png)

 case3：node的左子有右子  用node左子树中的中序前件(记为pSym)替代node。  

操作语句为：   

```c
  tmp = prev->right->left;  /* 用tmp暂存pSym的左子 */ 
  prev->right->left = node->left; /* 用pSym替代node   */ 
  prev->right->right = node->right ; 
  root->L/R = prev->right;  /* root的左/右子指向pSym */ 
  prev->right = tmp;    /* prev的右子指向tmp  */
```

![image-20240621221319371](/img/wdz_jr_final/image-20240621221319371.png)

(注：就是如果要删除node没有左子，用右子替代，如果有左子，用距离node最近的中序前件替换)

##### 二叉搜索树删除结点程序

删除结点包括两个函数：   删除结点的函数`deleteNode() `  查找并删除结点的函数`deleteBST()`

#####  删除结点的函数`deleteNode()  `

如果node是root的左子，编程时将L/R改为left。 

如果node是root的右子，编程时将L/R改为right。 

```c
BST * deleteNode(BST *root, BST *node) 
  { 
       /* case1：node无左子。用其右子替代node      */ 
       if(node->left == NULL) 
            root->L/R = node->right; 
       /* case2：node的左子无右子。用其左子替代node    */ 
       else if(node->left->right == NULL) 
       { 
            node->left->right = node->right; 
            root->L/R = node->left; 
       } 
       /* case3：node的左子有右子。        */ 
       /*   用node左子树中的中序前件(记为pSym)替代node   */ 
       else if(node->left->right != NULL) 
       { 
            for(prev=node->left; prev->right->right; prev=prev->right);  /* 查找pSym(prev->right) */ 
            tmp = prev->right->left;  /* 用tmp暂存pSym的左子 */ 
            prev->right->left = node->left;  /* 用pSym指向node的左右子 */ 
            prev->right->right = node->right ; 
            root->L/R = prev->right;  /* 用root的左/右子指向pSym */ 
            prev->right = tmp;    /* 用prev的右子指向tmp  */ 
       } 
       return(node) 
  } 
```

#####  查找并删除结点的函数`deleteBST() `

```c
BST *deleteBST(BST *root, BST *node, int key) 
  { 
       if(node == NULL) 
            return(NULL); 
       else if(key == node->key) 
       return( deleteNode(root, node) );    /* 调用deleteNode()删除node */ 
       else if(key < node->key) 
            return( deleteBST(node, node->left, key) ); /* 左查找和删除结点node */ 
       else if(key > node->key) 
            return( deleteBST(node, node->right, key) ); /* 右查找和删除结点node */ 
       return(NULL); 
  } 
```

##### 删除BST根结点  

**为了在删除BST结点时，使用统一的操作语句**。

如同链表中的哨兵，可在BST根结点Root 之上**设置一个虚根结点`virRoot`**。

令`virRoot->right=Root，virRoot->key=mini`，mini小于所有的结 点值。  

设置虚根结点的函数`virtualRoot`为：   

```c
BST *virtualRoot(BST *Root, int mini) 
  { 
       BST *node; 
       if((node = (BST *)malloc(sizeof(BST))) == NULL) 
            exit(0); 
       node->left = NULL; 
       node->right = Root; 
       node->key = mini;   /* mini小于所有的结点值  */ 
       return(node); 
  } 
 调用语句： 
  Root = virtualRoot(Root, mini=-1);  /* 假定所有的结点值为正数 */
```



## 图

### 图的存储形式

图的存储有多种形式，**邻接矩阵和邻接表**是两种常用的形式。

#### 邻接矩阵 

设G=(V, E)是图，V={v~1~, v~2~ , …, v~n~}，则可定义一个$n\times n$的邻接矩阵A。 

无向图的邻接矩阵是对称的，A[i,j]==A[j,i]，有向图的邻接矩阵不一定是对称的。

两者邻接矩阵所需存储空间分别为n^2^/2和n^2^。  

例如，无向图G1和有向图G2可以分别用邻接矩阵A1和A2表示。  

A2中的**粗体字**表示非对称的有向边。

![image-20240622003239541](/img/wdz_jr_final/image-20240622003239541.png)

#### 邻接表 

在图G=(V,E)中，若边(vi,vj)∈E，顶点vi,vj∈V，则称vj和vi互为邻接顶点。  

邻接表仅仅存储各邻接顶点的信息。邻接表可由**表头和表链**组成。表头存储所有**顶点**的 数值及其指向的表链。表链存储每个顶点**相邻边的终点**在表头中的位置。  

以下介绍采用**表头/表链**形式实现邻接表存储的两个方案。  

(1) 采用**一维数组/动态数组**方案存储邻接表。  

(2) 采用**链表/链表**方案存储邻接表。

##### 用数组存储邻接表示例

采用一维数组/动态数组方案存储n个结点的表头和表链。  

数据定义：

```c
  #define M  100 
  #define VERTEX struct vertex 
  VERTEX  
  { 
       char  key[5];  
       int   *link;  /* 表链指针 */ 
  }; 
  VERTEX  Vertex[M]; /* n<M  */
```

用数组Vertex存储邻接表。Vertex[k].key存储结点值，k为数组下标，k=0,...,n-1。  

用动态数组Vertex[k].link指向表链，表链的成员Vertex[k].link\[j](j=1,...,m)存储邻接顶点在表头中的地址，m为顶点Vertex[k]的邻接顶点数。 

![image-20240622003528601](/img/wdz_jr_final/image-20240622003528601.png)

##### 用链表存储邻接表示例

采用链表/链表方案存储n个结点的表头和表链。 

数据定义： 

``` c
  #define VTEX  struct vertex 
  #define EDGE  struct edge 
  VTEX 
  { 
       char  key[5]; 
       VTEX  *next;  /* 下一顶点指针 */ 
       EDGE *edge;  /* 表链指针  */ 
  }; 
  EDGE 
  { 
       VTEX  *vertex;  /* 顶点指针  */ 
       EDGE  *next;  /* 下一条边指针 */ 
  }; 
  VTEX  *Vertex;   /* 表头首指针 */ 
```

![image-20240622003823893](/img/wdz_jr_final/image-20240622003823893.png)

指针Vertex指向表头，表头单元的成员key存储结点值，指针next指向下一个顶点， 指针edge指向表链。  

表链单元的成员指针vertex存储邻接顶点在表头中的地址。指针next指向下一条邻接 边。  

邻接表的图形表示示例(地址虚构)。 

![image-20240622003834301](/img/wdz_jr_final/image-20240622003834301.png)

#### 十字链表

根据矩阵的不同形态，可采用不同的存储方法。例如上三角矩阵、下三角矩阵、对角矩 阵、带状矩阵等，称为特殊矩阵，需要另行设计专用的存储方法。  

很多应用中矩阵的非零元数量占矩阵容量比例小于5-10%，而且非零元的分布没有规 律，则为**稀疏矩阵(sparse matrix)**。

十字链表仅需存储非零元，**适用于存储稀疏矩阵。**  

数据定义示例： 

```c
#DEFINE V struct v 
  V 
  { 
       int  key, row, col; 
       V  *down, *right; 
  }; 
  V  *Vhead;  /* 总表头 */ 
```

![image-20240622003936332](/img/wdz_jr_final/image-20240622003936332.png)

总表头(稀疏矩阵指针)指向一个纵横双向的十字链表。  

十字链表由四个部分组成，使用统一形式的存储单元。 

(1) 非零元是十字链表的实体部分。key表示非零元的数值(顶点值)。row和col表示非零元所在的行号和列号，down指向本列下一个非零元，right指向本行下一个非零元。  

(2) 行表头指向本行首个非零元，所有的行表头组成行表头链表。  

(3) 列表头指向本列首个非零元，所有的列表头组成列表头链表。  

(4) 总表头的成员指针down和right分别指向行表头链表和列表头链表。 

![image-20240622004804176](/img/wdz_jr_final/image-20240622004804176.png)

![image-20240622004832963](/img/wdz_jr_final/image-20240622004832963.png)

![image-20240622004842004](/img/wdz_jr_final/image-20240622004842004.png)

### 图的遍历

####  图的基本操作

 查找顶点或查找子图  

 寻找通路或回路  

 添加顶点或合并两个图  

 删除顶点或子图  

 遍历全部顶点

##### 图的遍历

从某一顶点出发，按照某种法则沿着边逐个访问顶点，直至遍及全图。  当图为连通时，遍历可行。

#####  常用的遍历方法

DFS：深度优先搜索法(Depth First Search)  

BFS：广度优先搜索法(Breadth First Search)  

对树来说，树的DFS就是树的前序遍历，树的BFS就是树的层次遍历

#### 数据定义

采用链表方案，用邻接表存储图。

```c
 #define   UNVISITED 0 
 #define   VISITED  1 
 #define   VTEX  struct vertex 
 #define   EDGE  struct edge 
 VTEX /* 表头结构 */ 
 { 
      char  key；   /* 顶点值  */ 
      int   flag；    /* 访问标记  */ 
      VTEX  *next;   /* 下一顶点指针 */ 
      EDGE  *edge;    /* 表链首指针 */ 
 }; 
 EDGE /* 表链结构 */ 
 { 
      VTEX  *vertex;   /* 邻接顶点指针 */ 
      EDGE   *next;   /* 下一表链指针 */ 
 }; 
 VTEX *Vertex;   /* 邻接表首指针 */ 
```

![image-20240622005055045](/img/wdz_jr_final/image-20240622005055045.png)

#### 深度优先搜索法

##### 算法描述

初始：所有顶点标记为未访问。**指定一个起始顶点**u。

从起始顶点u开始DFS：   如果该点**已访问，跳过**。   

如果该点未访问，访问之，并**加注访问标记**；然后对其**所有的邻接顶点**逐个DFS。

##### DFS函数示例

```c
void dfs(VTEX *vertex) 
{ 
     EDGE *edge; 
     if(vertex == NULL) 
          return;  
     printf("%c ", vertex->key);     /* 打印顶点 */ 
     vertex->flag = VISITED;     /* 访问标记 */ 
     for(edge=vertex->edge; edge!=NULL; edge=edge->next) 
          if(edge->vertex->flag == UNVISITED) 
               dfs(edge->vertex);     /* 递归调用dfs */ 
} 
 调用语句： 
dfs(Vertex); 
printf("\n"); 
```

![image-20240622005246168](/img/wdz_jr_final/image-20240622005246168.png)

#### 广度优先搜索法

#####  算法描述

初始：所有顶点标记为未访问。指定一个起始顶点u，进队。  

只要队列非空，出队顶点v，执行BFS：   

如果顶点已访问，跳过；   

如果顶点未访问，访问之，并加注访问标记；然后将其所有邻接顶点进队。  当队空时结束BFS。 

##### BFS函数示例

```c
void bfs(VTEX *vertex) 
{ /* 假设已有队列函数enQueue()和deQueue()  */ 
 VTEX *vtex; 
 EDGE *edge; 
 if(vertex == NULL)
     return;  
 enQueue(vertex);      /* vertex进队  */ 
 while( vtex = deQueue() )     /* 只要队非空 */ 
 { 
      if(vtex->flag == UNVISITED)  /* 如果vertex未访问 */ 
      { 
           printf("%c ", vtex->key);  /* 打印顶点  */ 
           vtex->flag = VISITED;   /* 标记顶点  */ 
           for(edge= vtex->edge; edge!=NULL; edge=edge->next) 
                if(edge->vertex->flag == UNVISITED) 
                     enQueue(edge->vertex); /* 邻接顶点进队 */ 
      } 
 } 
} 
 调用语句： 
bfs(Vertex); 
printf("\n");
```

### 最小生成树

遍历一个连通无向图，所有n个顶点加上遍历经过的n-1条边所构成的子图称作图的 **生成树**(Spanning Tree)。  

定义一个带权连通的无向图G=(V, E, W)，简称**有权图**。   

V={v0, v1 , …, vn-1}，E={e0,…,em-1 | ei=(vs, vt, w), vs,vt ∈V}，   

vs和vt分别为边ei的起点和终点，w是边ei的权(或可称为边的长度，记为len)。  

遍历一个有权图，**所有边权值之和最小**的生成树称为**最小生成树(MST，Minimum-cost  Spanning Tree)**。  

无论是生成树还是最小生成树，都不是唯一的。  

例如，右侧的两图都是左图G的最小生成树，总边长=40。 

![image-20240622010259699](/img/wdz_jr_final/image-20240622010259699.png)

#### Kruskal算法

##### 最小生成树的Kruskal(克鲁斯卡尔)算法

初始：V={v0, v1 , …, vn-1}，vi是以顶点自身为根的树。

树根数`numRoot=n`。  生成MST的过程：  

不断选择最短的边(`vs,vt|vs`和`vt`不属于同一棵树)，  

链接`vs`和`vt`，合并这两棵树，`numRoot--`。  

直至V中只剩一棵树(`numRoot==1`)，从而获得最小生成树MST。

##### Kruskal算法的程序

数据定义

```c
#define UNMST 0 /* 未入MST */ 
  #define INMST 1 /* 已入MST */ 
  #define EDGE struct edge 
  #define VTEX struct vertex  
  EDGE 
  { 
       int len;      /* 边的长度 */ 
       VTEX *vs, *vt;    /* 起点和终点*/ 
       EDGE *next;    /* 下一条边 */  
  }; 
  VTEX  
  { 
       char key[5];     /* 顶点名 */ 
       EDGE *edge;    /*指向该顶点的边 */ 
       VTEX *next;     /* 下一顶点 */ 
   };
  EDGE *headE=NULL;   /* 边链表哨兵指针 */ 
  VTEX *headV=NULL;   /* 顶点链表哨兵指针 */ 
```

![image-20240622010459873](/img/wdz_jr_final/image-20240622010459873.png)

##### 链表含义 

 **逐条输入所有的边**(vs, vt, len)，**形成按边长升序排序**的边链表。每条边的起点指针vs和终 点指针vt分别指向顶点链表中相应的顶点，从而生成顶点链表。  

 **顶点链表**是用**链表存储**的最小生成树的**逆形式**。顶点链表生成时，**边指针edge都指向空**。 生成MST后，除了根结点的edge指向空，其他各顶点的edge都链接指向该顶点的边 edge(vs, vt)。因此**每个顶点都可以从edge直至追溯到根结点**。 

![image-20240622010713941](/img/wdz_jr_final/image-20240622010713941.png)

##### 辅助函数`input()`：

输入所有的边，生成顶点链表和按边长升序的边链表。

```c
while(成功获取输入边的信息(keyS, keyT, len)) 
  { 
       动态申请内存，创建边edge， 
       edge->vs = makeVertex(keyS);  /* keyS为起点名 */ 
       edge->vt = makeVertex(keyT);  /* keyT为终点名 */ 
       edge->len = len; 
       insertEdge(edge);    /* 将edge插入边链表 */ 
  } 
```

##### 辅助函数`makeVertex()`：

在顶点链表中创建顶点，或者获取顶点链表中的顶点。

```c
VTEX *makeVertex(char *key) 
{ 
     VTEX *prev, *vertex; 
     for(prev=headV; prev->next; prev=prev->next) 
          if(strcmp(prev->next->key, key) == 0) 
               return(prev->next);  /* 顶点已存在，返回顶点地址 */ 
     if((vertex = (VTEX *)malloc(sizeof(VTEX))) == NULL) 
          exit(0);      /* 顶点不存在，分配顶点空间 */ 
     strcpy(vertex->key, key);   /* 顶点名赋值    */ 
     vertex->edge = NULL;    /* 链接边初始为空   */ 
     vertex->next = prev->next;   /* 插入顶点     */ 
     prev->next = vertex; 
     numRoot++;      /* 树根数递增    */ 
     return(vertex);      /* 返回顶点地址    */ 
}
```

##### 辅助函数`insertEdge()`：

将边按升序插入边链表。

```c
void insertEdge(EDGE *edge) 
{ 
 EDGE *prev; 
 for(prev=headE; prev->next; prev=prev->next) 
      if(edge->len < prev->next->len) 
           break; 
 edge->next = prev->next; 
 prev->next = edge; 
} 
```

##### 生成最小生成树的函数`makeMST()`

```c
void makeMST() 
{ 
     EDGE *edge; 
     VTEX *vs, *vt, *vsRoot, *vtRoot, *vtmp; 
     for(edge=headE->next; edge && numRoot>1; edge=edge->next) 
     { 
          vsRoot = getRoot(edge->vs); /* 获取vs的树根   */ 
          vtRoot = getRoot(edge->vt); /* 获取vt的树根   */ 
          if(vsRoot == vtRoot)    /* vs和vt为同根生  */ 
               continue;  
          vt = edge->vt; 
          vs = edge->vs; 
          if(!vs->edge && vt->edge)   /* vs是根， vt不是根  */ 
          {       /* 交换vs和vt   */ 
               vtmp = edge->vt;   
               edge->vt = edge->vs; 
               edge->vs = vtmp; 
          } 
          if(vs->edge && vt->edge)  /* vs和vt都不是根  */ 
               revEdge(vt->edge);  /* 反转vt到根的边  */ 
          edge->vt->edge = edge;  /* 链接vs和vt，合并两棵树 */ 
          numRoot--;     /* 树根数递减   */ 
     } 
} 
```

#####  辅助函数`getRoot()`：

获取顶点所在树的根。

```c
VTEX *getRoot(VTEX *vertex) 
{ 
     if(vertex->edge == NULL) 
          return(vertex); 
     return( getRoot(vertex->edge->vs) ); 
} 
```

##### 链接vs和vt的操作解析

如果vs和vt不是同根生(不属于同一棵树)，执行链接vs和vt的操作：  

(1) 如果vt是根：链接vs和vt。 

(2) 如果vt不是根，vs是根：先交换vs和vt，再链接vs和vt。  

(3) 如果vt和vs都不是根：先将vt反转至根，再链接vs和vt。 

![image-20240622011147814](/img/wdz_jr_final/image-20240622011147814.png)

![image-20240622011156154](/img/wdz_jr_final/image-20240622011156154.png)

##### 辅助函数`revEdge()`：

反转从顶点edge->vt到根的所有边

```c
void revEdge(EDGE *edge)   /* 反转当前边edge的函数    */ 
{ 
     EDGE *vsEdge;     /* 父顶点vs指向的边为待转边   */ 
     VTEX *vtmp; 
     if(edge == NULL) 
          return;     /* 结束递归       */ 
    ① vsEdge = edge->vs->edge; /* 将edge->vs指向的边暂存为待转边 */ 
    ② vtmp = edge->vs;    /* 反转当前边edge：交换vs和vt  */ 
     edge->vs = edge->vt;   /* 反转后vs指向的边成为vt指向的边 */ 
     edge->vt = vtmp; 
    ③ edge->vt->edge = edge;  /* 更新edge->vt指向的边    */ 
    ④ revEdge(vsEdge);   /* 递归反转待转边vsEdge    */ 
} 
```

![image-20240622011249951](/img/wdz_jr_final/image-20240622011249951.png)

![image-20240622011303961](/img/wdz_jr_final/image-20240622011303961.png)

（简单来说：从边入手，从最短边一个个连接，直到所有顶点连接。ds和dt两棵树，则**必须dt为根**，然后ds连接dt)

### 最短路径问题的Dijkstra算法

有权图中最短路径问题(shortest paths)的算法，由荷兰人狄克斯特拉(Dijkstra)于1959 年提出解决算法，因此称为Dijkstra算法。  

定义一个有权图G=(V, E, W)， V={v0, v1 , …, vn-1}，  

E={e0,…,em-1, | ei=(vs, vt, wi), vs,vt ∈V}，wi是边ei的权(或可称为边的长度，记为len)。  

给定一个源点u，求从u出发到其余各顶点的最短路径。

####  Dijkstra算法 

定义S和U两个集合，S集合包含已入最短路径的顶点，U集合包含未入最短路径的 顶点，各顶点v(v∈V)的路径长度为Len(v)。 

初始：所有顶点的路径长度均置为所有边长之和的最大值`maxLen`。  

S = φ，U = V。指定源点v~src~，Len(v~src~)=0  

生成最短路径(扩展顶点和边)的过程：  

在U中不断选择路径长度Len最短的顶点vs(start vertex)。  

S = S + {vs}，U = U - {vs}  

根据vs所有相邻边(vs,vt | vt∈V)的长度，求取所有vt的最短路径。  

直至U == φ，从而获得所有的最短路径。 

![image-20240622011458702](/img/wdz_jr_final/image-20240622011458702.png)

####  Dijkstra算法的程序

##### 数据定义

```c
  #define EDGE struct edge 
  #define VTEX struct vertex 
  EDGE 
  { 
       int len;      /* 边的长度 */ 
       VTEX *vs;     /* 边的起点 */ 
       VTEX *vt;     /* 边的终点 */ 
       EDGE *next;    /* 下一条边 */  
  }; 
  VTEX { 
       char key[5];     /* 顶点名  */ 
       int len;     /* 最短路径长度 */ 
       int flag;     /* 最短路径标志 */ 
       EDGE *link;    /* 邻接表表链 */ 
       EDGE *edge;   /* 链接该顶点的边*/ 
       VTEX *next;     /* 下一顶点  */ 
   }
   EDGE *headE=NULL;   /* 边链表哨兵指针 */ 
```

#####  采用扩充的邻接表

 在表头中用link指向表链，从而构成图的邻接表。  

 每读取一条边edge(u, v)，将边(u, v)及其反向边(v, u)分别存入顶点u和v的表链。  

 在表头中**用edge指向链接该顶点的边，从而构成树的逆形式存储**。 

![image-20240622011720345](/img/wdz_jr_final/image-20240622011720345.png)

#####  辅助函数input()：

输入所有的边，生成扩充的邻接表。

```c
while(fscanf(fp, "%s%s%d", keyS, keyT, &len) == 3) 
 { 
  if((edge = (EDGE *)malloc(sizeof(EDGE))) == NULL) 
       exit(0); 
  edge->vs = makeVertex(keyS); 
  edge->vt = makeVertex(keyT); 
  edge->len = len; 
  maxLen += len;    /* 获取路径的最大值   */ 
  makeLink(edge);     /* 将edge插入表链   */ 
 } 
for(vertex=headV->next; vertex; vertex=vertex->next) 
      vertex->len = maxLen;   /* 所有路径长度为最大值  */
```

![image-20240622011819323](/img/wdz_jr_final/image-20240622011819323.png)

##### 辅助函数makeVertex()：

生成表头。

```c
VTEX *makeVertex(char *key) 
  { 
       VTEX *prev, *vertex; 
       for(prev=headV; prev->next; prev=prev->next) 
            if(strcmp(prev->next->key, key) == 0) 
                return(prev->next);   /* 顶点已存在，返回顶点地址 */ 
       if((vertex = (VTEX *)malloc(sizeof(VTEX))) == NULL) 
        	exit(0);       /* 顶点不存在，分配顶点空间 */ 
       strcpy(vertex->key, key);    /* 顶点名赋值    */ 
       vertex->flag = UNPATH;     /* 顶点初始为未入最短路径 */ 
       vertex->link = NULL;      /* 表链初始为空    */ 
       vertex->edge = NULL;     /* 链接边初始为空   */ 
       vertex->next = prev->next;    /* 插入顶点     */ 
       prev->next = vertex; 
       return(vertex);       /* 返回顶点地址    */ 
  } 
```

##### 辅助函数`makeLink()：`

将边(u, v)及其反向边(v, u)分别存入顶点u和v的表链。 

```c
void makeLink(EDGE *edge) 
{ 
 EDGE *rEdge;      /* 反向边      */ 
 edge->next = edge->vs->link;  /* 将边edge插入vs的表链  */ 
 edge->vs->link = edge; 
 if((rEdge = (EDGE *)malloc(sizeof(EDGE))) == NULL) 
  	exit(0);       /* 生成反向边rEdge    */ 
 rEdge->vs = edge->vt; 
 rEdge->vt = edge->vs; 
 rEdge->len = edge->len; 
 rEdge->next = edge->vt->link;  /* 将反向边插入vt的表链   */ 
 edge->vt->link = rEdge; 
} 
```

#####  辅助函数`getSource()`：

由用户选择源点。

```c
 printf("请选择源点: "); 
 scanf("%s", keyS); 
 for(prev=headV; prev->next; prev=prev->next) 
      if(strcmp(keyS, prev->next->key) == 0) 
           break; 
 if(prev->next == NULL) 
      error("cannot found source vertex"); 
 source = prev->next; 
 source->len = 0; 
```

##### 求取最短路径的函数`shortPath() `

```c
void shortPath()      /* 求取最短路径的函数  */ 
{ 
 int minPath; 
 VTEX *vtex, *vertex;  /* vertex表示待扩展最短路径的的顶点 */ 
 EDGE *edge; 
 while(1) 
 { 
      vertex = NULL; 
      minPath = maxLen; 
      for(vtex=headV->next; vtex; vtex=vtex->next) 
      { /* 在U中寻找路径长度最短的顶点  */ 
          if(vtex->flag == UNPATH && vtex->len < minPath) 
          { 
              minPath = vtex->len; 
              vertex = vtex; 
          } 
      } 
      if(vertex == NULL)   /* 所有顶点已选入最短路径 */ 
           return;      /* 结束求取最短路径的过程 */ 
      vertex->flag = PATHED;  /* 顶点vertex选入最短路径 */ 
      for(edge=vertex->link; edge; edge=edge->next) 
      { /* 更新顶点vertex所邻接顶点的最短路径  */ 
           if(edge->vt->len > vertex->len + edge->len) 
           { 
                edge->vt->len = vertex->len + edge->len; 
                edge->vt->edge = edge; 
           } 
      } 
   } 
} 
```

![image-20240622012229076](/img/wdz_jr_final/image-20240622012229076.png)

![image-20240622012245389](/img/wdz_jr_final/image-20240622012245389.png)

(U中顶点搜寻外推+路径最小len辐射)

##### 最小生成树算法与最短路径算法的比较

最小生成树好比是**建造各城市之间公路的最少总费用**，最短路径好比是**从源点到各城市间的路程**。两者相比，既类似又不相同。

![image-20240622012333576](/img/wdz_jr_final/image-20240622012333576.png)
